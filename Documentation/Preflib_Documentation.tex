\documentclass{report}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage[basic]{complexity}
\usepackage{tikz}
\usepackage{hyphenat}
\usepackage{graphicx}
\usepackage{mathpazo}
\usepackage{nicefrac}
\usepackage{fontawesome}
\usepackage{multicol}

\usepackage[authoryear]{natbib}

\usepackage{geometry}
\geometry{vmargin = 2.5cm, hmargin = 2.5cm}

\usepackage{array}
\newcolumntype{L}[1]{>{\raggedright\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{C}[1]{>{\centering\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}
\newcolumntype{R}[1]{>{\raggedleft\let\newline\\\arraybackslash\hspace{0pt}}m{#1}}

\renewcommand{\arraystretch}{1.15}

\usepackage{tikz}
\usetikzlibrary{automata, positioning, calc, shapes, arrows, fit}
\newcommand{\circled}[1]{\tikz[baseline=(char.base)]{
		\node[shape=circle, draw, inner sep=0.5pt] (char) {#1};}}

\usepackage[unicode=true, bookmarks=false, breaklinks=true, pdfborder={0 0 1},colorlinks=true]{hyperref}
\hypersetup{linkcolor=blue,citecolor=blue,filecolor=blue,urlcolor=blue}


\begin{document}
	\title{Preflib 2.0}
	\author{Simon Rey}
	\maketitle
	
	\tableofcontents
	
	\chapter{Developing PrefLib}
	
	In this chapter, we detail the inner structure of PrefLib. We will first focus on the folder structure, explaining the role of each file. The second part of this chapter is devoted to the structure of the database. 
	
	The aim of this chapter is to provide all the necessary information to someone who would like to develop further the website. If you are only interested in maintaining the website and do some small changes, the second chapter might be more interesting to you.
	
	\section{Folder Structure}
	
	The folder structure of the project follows that of a typical Django project with one application. The overall Django project is called \texttt{preflib} and the main, and only, django application is called \texttt{preflibApp}. The overall folder structure can be found in Figure \ref{fig:folderStruct}. In what follows, we give an explanation for each folder and files.
	
	\begin{figure}
		\begin{multicols}{2}
			\begin{itemize}
				\item[\faFolderO] preflib
				\begin{itemize}
					\item[\faFileO] settings.py
					\item[\faFileO] urls.py
					\item[\faFileO] wsgi.py
				\end{itemize}
				\item[\faFolderO] preflibApp
				\begin{itemize}
					\item [\faFolderO] management
					\begin{itemize}
						\item[\faFolderO] commands
						\begin{itemize}
							\item[\faFileO] adddataset.py
							\item[\faFileO] generatezip.py
							\item[\faFileO] initializedb.py
							\item[\faFileO] updatemetadata.py
							\item[\faFileO] updatepapers.py
						\end{itemize}
					\end{itemize}
					\item[\faFolderO] preflibtools
					\begin{itemize}
						\item[\faFileO] drawing.py
						\item[\faFileO] graph.py
						\item[\faFileO] instance.py
						\item[\faFileO] properties.py
					\end{itemize}
					\item[\faFolderO] static
					\begin{itemize}
						\item[\faFolderO] adminLogo
						\begin{itemize}
							\item[\faFilesO] images for the admin menu
						\end{itemize}
						\item[\faFolderO] css
						\begin{itemize}
							\item[\faFileO] nouislider.css
							\item[\faFileO] style.css
						\end{itemize}
						\item[\faFolderO] data
						\begin{itemize}
							\item[\faFolderO] CD
							\item[\faFolderO] ED
							\item[\faFolderO] MD
							\item[\faFolderO] types
						\end{itemize}
						\item[\faFolderO] datatoadd
						\item[\faFolderO] js 
						\begin{itemize}
							\item[\faFileO] nouislider.js
						\end{itemize}
						\item[\faFolderO] types
						\begin{itemize}
							\item[\faFileO] dataTypesImages.tex
							\item[\faFilesO] images to present the types
						\end{itemize}
						\item[\faFileO] crisner.png
						\item[\faFileO] gitHubLogo.png
						\item[\faFileO] papers.bib
						\item[\faFileO] preflibADTCite.txt
						\item[\faFileO] preflibADTPaper.pdf
						\item[\faFileO] preflibTrendsComSoCChapter.pdf
						\item[\faFileO] preflibTrendsComSoCCite.txt
					\end{itemize}
					\item[\faFolderO] templates
					\begin{itemize}
						\item[\faFolderO] includes
						\begin{itemize}
							\item[\faFilesO] HTML files that can be included
						\end{itemize}
						\item[\faFolderO] preflib
						\begin{itemize}
							\item[\faFilesO] main HTML files
						\end{itemize}
						\item[\faFileO] 400.html
						\item[\faFileO] 403.html
						\item[\faFileO] 404.html
						\item[\faFileO] 500.html
					\end{itemize}
					\item[\faFolderO] templatetags
					\begin{itemize}
						\item[\faFileO] extratags.py
					\end{itemize}
					\item[\faFileO] admin.py
					\item[\faFileO] apps.py
					\item[\faFileO] choices.py
					\item[\faFileO] forms.py
					\item[\faFileO] models.py
					\item[\faFileO] scripts.py
					\item[\faFileO] urls.py
					\item[\faFileO] views.py
				\end{itemize}
			\end{itemize}
		\end{multicols}
		\caption{Folder Structure of the Project, some less relevant files have been omitted.}
		\label{fig:folderStruct}
	\end{figure}

	\medskip

	We start by detailing the \texttt{preflib} folder.

	\section*{\faFolderO{}  preflib}
	
	The \texttt{preflib} folder contains the files that have an impact on the entire project. This is the highest folder in the Django hierarchy. Files in there are mainly used to set up the global parameters of the project.
	
	\paragraph*{\faFileO{} settings.py} This is the main files for the global settings. Among other things, you will find there the settings for the database, the location of the static files, the debugging mode, the installed applications, ... Not that this file is not on the git for security reasons.
	
	\paragraph*{\faFileO{} urls.py} Use this file to set up the global rules for urls. Whenever a request passed over to Django, this file is used to decide where to send the request next. Handlers for the errors (404, 500, etc...) are also defined there.
	
	\paragraph*{\faFileO{} wsgi.py} This is only used to set up the connection between Django and whatever WSGI tool is used (uWSGI, Gunicorn, Passenger). If you did not understand the previous sentence, you will most likely never have to deal with this file.
	
	\medskip 
	
	Let us now move to the \texttt{preflibApp} folder.
	
	\section*{\faFolderO{} preflibApp}
	
	This folder contains all the files related to the \texttt{preflibApp} Django application. Because this is the only application we have, it thus contains the entire website. Let us first go through the Python files you can find there, sub-folders will be examined afterwards.
	
	\paragraph{\faFileO{} urls.py} This file sets the url patterns for the application. It is in there that the link between an URL and the corresponding view is made. It is also in there that the set of all acceptable URLs (that will not return a 404) is defined. When a request is passed over to Django, the URL is first filtered by the \texttt{urls.py} file in the \texttt{preflib} folder which then calls the url pattern defined in this file to know what view to call for.
	
	\paragraph{\faFileO{} views.py} In Django, a view is a function that takes an input a request and that return a rendered template (an HTML file). This files gathered all the views. This file is probably the most important one as it includes all the code that is run once a request arrives: updating the database, computing so stuff, filter the entries of the database, etc.
	
	\paragraph{\faFileO{} forms.py} Django offers a Python class to deal with forms that makes it easier to check whether they have been properly filled in etc... The forms are defined in this file. It, for instance, includes the search form, the login form, etc.
	
	\paragraph{\faFileO{} models.py} A model in Django is the corresponding Python class to a table in the database. In this files all the models are described in Python. Django then reads through this file and create the database accordingly. The entire database is thus defined in there.
	
	\paragraph{\faFileO{} choices.py} Choices are lists of constant values that are not meant to change often (they would be in the database otherwise). An example is the set of data category for instance. This files gathered them all.
	
	\paragraph{\faFileO{} admin.py} In this file, one can register the models so that they appear in the Django admin website.
	
	\paragraph{\faFileO{} scripts.py} This file defines few useful functions for management purposes.
	
	\paragraph{\faFileO{} apps.py} This is a file that is used by Django to know the application exists. Do not modify it.
	
	\medskip
	
	For the rest of this section, we will explore the sub-folders present in the \texttt{preflibApp} folder.
	
	
	\section*{\faFolderO{} preflibApp/templates}
	
	In Django, a template is an HTML that can incorporate some Django tags in it. They are the main files containing the HTML code of the website. They all are gathered in the \texttt{templates} folder. It contains all the template to render the errors: \texttt{400.html}, \texttt{404.html}, etc. It also contains several sub-folders used to separate the templates based on their use.
	
	\paragraph*{\faFolderO{} includes} This folder gathers all the templates that can be included in some other templates using the \texttt{\{\% include `template' \%\}} Django tag. These files are:
	\begin{itemize}
		\item[\faFileO] footer.html: the footer displayed at the bottom of a page;
		\item[\faFileO] header.html: the header displayed at the top of a page;
		\item[\faFileO] htmlHeaderContent.html: the content of the HTML header that is shared with all pages;
		\item[\faFileO] metadataCategorySearch.html: the code used to render a search widget in the search page;
		\item[\faFileO] paginator.html: the code used to render a paginator in a page.
	\end{itemize}
	
	\paragraph*{\faFolderO{} preflib} This folder gathers the templates used to render all the pages of the website. We list them below.
	\begin{multicols}{2}
		\begin{itemize}
			\item[\faFileO] about.html: the about page
			\item[\faFileO] admin.html: the admin menu
			\item[\faFileO] adminadddataset.html: the admin page for adding datasets
			\item[\faFileO] adminlog.html: the admin page for viewing logs
			\item[\faFileO] adminpaper.html: the admin page for adding a paper
			\item[\faFileO] adminzip.html: the amdin page for zipping the files
			\item[\faFileO] data.html: the data page describing the structure of the data
			\item[\faFileO] dataformat.html: the page explaining the format we use
			\item[\faFileO] datametadata.html: the page describing the metadata
			\item[\faFileO] datapatch.html: the template for rendering a datapatch
			\item[\faFileO] datasearch.html: the search page
			\item[\faFileO] dataset.html: the template for rendering a dataset
			\item[\faFileO] datasetall.html: the template for rendering a category of data
			\item[\faFileO] datatypes.html: the page describing the types
			\item[\faFileO] index.html: the main page of the website
			\item[\faFileO] toolscris.html: the Crisner tool page
			\item[\faFileO] toolsivs.html: the Iterative Voting Simulator page
			\item[\faFileO] toolsskdg.html: the Kidney Dataset Generator page
			\item[\faFileO] userlogin.html: the login page
			\item[\faFileO] usernewaccount.html: the page to create new account
			\item[\faFileO] userprofile.html: the page displaying the profile of a user
		\end{itemize}
	\end{multicols}
	
	\section*{\faFolderO{} preflibApp/templatetags}
	
	The \texttt{templatetags} folder is used to describe user-defined tags that can then be used in the templates. It contains a single file---\texttt{extratags.py}---where the extra tags are defined.
	
	\section*{\faFolderO{} preflibApp/static}
	
	The \texttt{static} folder contains all the static files that are used (unsurprisingly). This folder is the one considered by the \texttt{collecstatic} management command from Django.
	
	\paragraph*{\faFolderO{} adminLogo} This folder gathers all the images of the logo used for the admin menu. Note that it might disappear in some later versions.
	
	\paragraph*{\faFolderO{} css} This folder gathers all the CSS files. There are currently two of them: \texttt{style.css} which is the main CSS file for the style of the website and \texttt{nouislider.css} that is used to render the sliders in the search page.
	
	\paragraph*{\faFolderO{} js} This folder gathers all the JavaScript files. The only file in there is used for the sliders in the search page.
	
	\paragraph*{\faFolderO{} types} This folder gathers the images used to present the types together with the TeX file generating some of them.
	
	\paragraph*{\faFileO{} crisner.png} This image illustrates the Crisner tool.
	
	\paragraph*{\faFileO{} gitHubLogo.png} This image is the GitHub logo displayed in the footer.
	
	\paragraph*{\faFileO{} papers.bib} This bib file is the one read by the management command \texttt{updatepapers}. It contains all the bib entries that are then put in the database as ``papers using PrefLib''.
	
	\paragraph*{\faFilesO{} preflib citations} For the ADT paper and the Trends in ComSoC chapter, the pdf and a txt file with the bib information are provided.
	
	\section*{\faFolderO{} preflibApp/management/commands}
	
	The \texttt{management/commands} folder includes the user-defined commands that one can access using the Django's management tool. Each file in this folder contains a class \texttt{Command} which should contain some specific methods. Importantly, once defined and put in this folder, the command can be accessed as any other management command, for instance from the command line using: \texttt{python3 manage.py adddataset}.
	
	\paragraph*{\faFileO{} adddataset.py} This command is used to add datasets to the database. Only zip files located in the folder \texttt{static/datatoadd} can be retrieved by this command. Two arguments can be passed to the command, either \texttt{--file zipfilename} to add only a specific zip file, or \texttt{--all} to add all the zip files in the \texttt{static/datatoadd} folder to the database.
	
	When adding a dataset, the command unzip the archive in a temporary folder. It then goes through the files to find the info file used to get all the information for the dataset. Then, each file is added to the database, together with its datapatch (if needed). Note that the metadata are not computed when adding a dataset. 
	
	\paragraph*{\faFileO{} generatezip.py} This command is used to generate all the zip files served by the website. It first generates the zip files for the dataset, creating the info file with the entry in the database. In a second time, it generates the zip files per type of data.
	
	\paragraph*{\faFileO{} initializedb.py} This command is only run once, at the very beginning, to populate the database with the entries that are needed. It mainly sets up the metadata.
	
	\paragraph*{\faFileO{} updatemetada.py} This command computes the metadata for the data files. Two options can be passed to the command. When used with \texttt{--dataset datasetAbbreviation}, only the metadata for the given dataset will be computed. One can also use \texttt{--noDrawing} to avoid generating the images for the data file (which takes a lot of time).
	
	For each relevant data file, the command will go through all the \emph{active} metadata (see later what active mean here). Whenever an active metadata applies to the data type of the data file, the corresponding function is called to compute its value. If drawing is allowed, the relevant drawing method is also called.
	
	\paragraph*{\faFileO{} updatepapers.py} This command updates the list of papers that are using Preflib. It reads the bib file \texttt{static/papers.bib} and update the database accordingly.
	
	\section*{\faFolderO{} preflibApp/preflibtools} This folder contains the tools that were developed around PrefLib to work with the data. Note that this version is far from what you can find in the PrefLibTools repository on GitHub. These tools are mainly used to analyze the data when computing the relevant metadata.
	
	\paragraph*{\faFileO{} drawing.py} This file contains all the functions that are used to draw the images representing the data. 
	
	\paragraph*{\faFileO{} graph.py} This file contains the definition of the \texttt{Graph} class that we use to represent graphs and access several useful methods for them.
	
	\paragraph*{\faFileO{} instance.py} This file contains the class used to represent PrefLib instances. The methods for parsing the data file are defined there.
	
	\paragraph*{\faFileO{} properties.py} This file contains a collection of functions used to check whether some properties hold for a given instance. This is the main file used to compute the metadata of the instances.
	
	
	\section{Database Structure}
	
	In the following, we provide more details about the structure of the database behind Preflib.
	
	\medskip
	
	Let us first go through all the tables present in the database.
	
	\paragraph{\textsc{DataFile}} The most fundamental entity for Preflib is the datafile. The \textsc{DataFile} table contains a reference to all the datafiles that are in Preflib. The table does not contain the data in itself---it is stored in a file and not in the database---but all the relevant information about it: some basic details and datapatch in which the file is.
	
	\paragraph{\textsc{DataPatch}} The datapatch is the first level of classification of the datafile. It contains several datafile of different datatype. All the datafiles are based on the same preferences but the representation, the datatype, is different.
	
	\paragraph{\textsc{DataSet}} A dataset is a collection of datapatches. The datapatches will typically represent different years of the same election.
	
	\paragraph{\textsc{DataProperty}} A dataproperty is an additional information about a given datafile. It can have to do about the general properties of the data (number of candidates...) or about some more specific structure of the data (single-peakedness...).
	
	\paragraph{\textsc{Metadata}} The \textsc{Metadata} table stores all the different metadata available in the system. Their values are in the \textsc{DataProperty} table.
	
	\paragraph{\textsc{Paper}} This table stores the information about the papers which are using Preflib.
	
	\paragraph{\textsc{UserProfile}} All the informations about the users that are not in the Django User class are present in this table.
	
	\paragraph{\textsc{Log}} Logs of what is happening in the inside are gathers in this table.
	
	\medskip
	
	The following figure summarizes the links between the different tables and presents all the elements present in the tables.
	
	\begin{figure}
		\resizebox{\linewidth}{!}{
		\begin{tikzpicture}[shorten > = 5pt, shorten < = 5pt]
			\node[draw, rounded corners = 4pt, thick = 2pt, anchor = north east] (dataset) at (0, 0) {
				\begin{tikzpicture}
					\node[label = above:{\large \textsc{DataSet}}] {\begin{tabular}{rl}
						\textbf{name} & Name of the dataset \\
						\textbf{abbreviation} & Abbreviation of the dataset\\
						\textbf{extension} & Extension of the dataset \\
						\textbf{seriesNumber} & Series number of the dataset\\
						\textbf{description} & Few sentences about the dataset \\
						\textbf{requiredCitations} & Papers to cite when using \\& the dataset \\
						\textbf{selectedStudies} & Works related to the dataset \\
						\textbf{publicationDate} & Date at which the dataset \\& has been added \\
						\textbf{modificationDate} & Last time the dataset \\& has been modified
				\end{tabular}};
			\end{tikzpicture}};
			
			\node[draw, rounded corners = 4pt, thick = 2pt, below = 1cm of dataset] (datapatch) {
				\begin{tikzpicture}
					\node[label = above:{\large \textsc{DataPatch}}] {\begin{tabular}{rl}
					\textbf{dataSet} & Foreign key on the dataset \\
					\textbf{name} & Name of the datapatch \\
					\textbf{description} & Description of the datapatch \\
					\textbf{seriesNumber} & Series number of the datapatch \\
					\textbf{publicationDate} & Date at which the datapatch \\& has been added \\
					\textbf{modificationDate} & Last time the datapatch \\& has been modified
				\end{tabular}};
			\end{tikzpicture}};
			
			\node[draw, rounded corners = 4pt, thick = 2pt, below = 1cm of datapatch] (datafile) {
				\begin{tikzpicture}
					\node[label = above:{\large \textsc{DataFile}}] {\begin{tabular}{rl}
					\textbf{dataPatch} & Foreign key on the datapatch \\
					\textbf{dataType} & Type of the datafile\\
					\textbf{modificationType} & Modificaton type of the datafile\\
					\textbf{fileName} & Name of the file  \\
					\textbf{fileSize} & Size of the file \\
					\textbf{publicationDate} & Date at which the datafile \\& has been added \\
					\textbf{modificationDate} & Last time the datafile \\& has been modified \\
					\textbf{shortName()} & Method that returns the \\& shortname of the file
				\end{tabular}};
			\end{tikzpicture}};
		
			\node[draw, rounded corners = 4pt, thick = 2pt, anchor = north west] (metadata) at (1, 0) {
				\begin{tikzpicture}
					\node[label = above:{\large \textsc{Metadata}}] {\begin{tabular}{rl}
					\textbf{name} & Name of the metadata \\
					\textbf{shortname} & Shortname of the metadata \\
					\textbf{category} & Category of the metadata \\
					\textbf{description} & Description of the metadata \\
					\textbf{isActive} & Should the metadata be computed \\
					\textbf{isDisplayed} & Should the metadata be displayed \\
					\textbf{appliesTo} & Set of data type the metadata applies to \\
					\textbf{upperBounds} & Set of metadata upperbounded \\& by this metadata\\
					\textbf{innerModule} & Python module to compute the metadata \\
					\textbf{innerFunction} &  Python function to compute the metadata \\
					\textbf{innerType} & Python type of the metadata \\
					\textbf{searchWidget} & Widget to use in the search page\\
					\textbf{searchQuestion} & Question displayed in the search page\\
					\textbf{searchResName} & Header of the result table in \\& the search page\\
					\textbf{orderPriority} & Used to display the metadata \\& in the correct order\\
					\textbf{getAppliesToList()} & Method that returns appliesTo as a list
				\end{tabular}};
			\end{tikzpicture}};
			
			\node[draw, rounded corners = 4pt, thick = 2pt, below = 1cm of metadata] (dataprop) {
				\begin{tikzpicture}
					\node[label = above:{\large \textsc{DataProperty}}] {\begin{tabular}{rl}
					\textbf{dataFile} & Foreign key on the datafile \\
					\textbf{metadata} & Foreign key on the metadata \\
					\textbf{value} & Value of the property \\
					\textbf{getTypedValue()} & Method that returns the value \\& cast to the correct Python type 
				\end{tabular}};
			\end{tikzpicture}};
		
			\draw[->] (dataset) edge (datapatch);
			\draw[->] (datapatch) edge (datafile);
			\draw[->] (metadata) edge (dataprop);
			\draw[->] (dataprop) edge (datafile);
			
			\node[draw, rounded corners = 4pt, thick = 2pt, below = 1cm of datafile] (paper) {
				\begin{tikzpicture}
					\node[label = above:{\large \textsc{Paper}}] {\begin{tabular}{rl}
					\textbf{name} & Identifier of the paper \\
					\textbf{title} & Title of the paper \\
					\textbf{authors} & Authors of the paper \\
					\textbf{publisher} & Where the paper \\& has been published \\
					\textbf{year} & Year of publication \\
					\textbf{url} &  Link to the paper \\
					\textbf{publicationDate} & Date at which the \\& paper has been added
				\end{tabular}};
			\end{tikzpicture}};
		
			\node[draw, rounded corners = 4pt, thick = 2pt, below = 1cm of dataprop] (user) {
				\begin{tikzpicture}
					\node[label = above:{\large \textsc{UserProfile}}] {\begin{tabular}{rl}
					\textbf{user} & Foreign key on the Django user \\
					\textbf{firstname} & First name of the user \\
					\textbf{lastname} & Last name of the user \\
					\textbf{email} & Email of the user \\
					\textbf{affiliation} & Affiliation of the user \\
					\textbf{personnalURL} &  Link to the user's personnal page
				\end{tabular}};
			\end{tikzpicture}};
			
			\node[draw, rounded corners = 4pt, thick = 2pt, below = 1cm of user] (log) {
				\begin{tikzpicture}
					\node[label = above:{\large \textsc{Log}}] {\begin{tabular}{rl}
					\textbf{log} & Content of the log \\
					\textbf{logType} & Type of log \\
					\textbf{logNum} & Number of log of the given type \\
					\textbf{publicationDate} & Date at which the paper has been added
				\end{tabular}};
			\end{tikzpicture}};
		\end{tikzpicture}}
		\caption{Structure of the database}
	\end{figure}

	\chapter{Maintaining PrefLib}
	
\end{document}